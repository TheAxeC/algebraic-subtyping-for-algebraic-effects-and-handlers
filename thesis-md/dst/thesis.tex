\documentclass[master=cws,masteroption=ai, english]{kulemt}

\setup{title={Algebraic Subtyping for Algebraic Effects and Handlers},
  author={Axel Faes},
  promotor={Prof.~dr. ir. Tom Schrijvers},
  assessor={people},
  assistant={Amr Hany Saleh}}
% The following \setup may be removed entirely if no filing card is wanted
\setup{filingcard,
  translatedtitle=,
  udc=,
  shortabstract={}}



\setup{font=lm}

\usepackage[pdfusetitle,colorlinks,plainpages=false]{hyperref}
\usepackage[]{mathpartir}
\usepackage[]{xspace}
\usepackage[]{stmaryrd}
\usepackage[]{listings}
\usepackage[]{newtxmath}

\input{src/macros}

\begin{document}

\begin{preface}
  stuff
\end{preface}

\tableofcontents*

\begin{abstract}
  Algebraic effects and handlers are a very active area of research. An
  important aspect is the development of an optimising compiler. \eff is
  an ML-style language with support for effects and forms the testbed for
  the optimising compiler. However, the type-\&-effect system of \eff is
  unsatisfactory. This is due to the lack of some elegant properties. It
  is also awkward to implement and use in practice. This thesis proposes a
  new type-\&-effect system using intersections and unions for both types
  and effects. The type-\&-effect system and the type-\&-effect inference
  algorithm are given and are critically discussed. Several aspects of the
  system are formally proven. Finally, the system is experimentally
  validated using an implementation which is compared to several existing
  type-\&-effect systems.
\end{abstract}

\listoffigures
\listoftables

\chapter{List of Abbreviations and Symbols}\section*{Abbreviations}\begin{flushleft}
  \renewcommand{\arraystretch}{1.1}
  \begin{tabularx}{\textwidth}{@{}p{12mm}X@{}}
    LoG   & Laplacian-of-Gaussian \\
    MSE   & Mean Square error \\
    PSNR  & Peak Signal-to-Noise ratio \\
  \end{tabularx}
\end{flushleft}\section*{Symbols}\begin{flushleft}
  \renewcommand{\arraystretch}{1.1}
  \begin{tabularx}{\textwidth}{@{}p{12mm}X@{}}
    LoG   & Laplacian-of-Gaussian \\
    MSE   & Mean Square error \\
    PSNR  & Peak Signal-to-Noise ratio \\
  \end{tabularx}
\end{flushleft}

\mainmatter

\chapter{Introduction}\label{introduction}

The specification for a type-\&-effect system with algebraic subtyping
for algebraic effects and handlers is given in this document. The formal
properties of this system are studied in order to find which properties
are satisfied compared to other type-\&-effect systems. The proposed
type-\&-effect system builds on two very recent developments in the area
of programming language theory.

\paragraph{Algebraic subtyping}

In his December 2016 PhD thesis, Stephen Dolan (University of Cambridge,
UK), has presented a novel type system that combines subtyping and
parametric polymorphism in a particulary attractive and elegant fashion.
A cornerstone of his design are the algebraic properties that the
subtyping relation should respect.

\paragraph{Algebraic effects and handlers}

These are a new formalism for formally modelling side-effects
(e.g.~mutable state or non-determinism) in programming languages,
developed by Matija Pretnar (University of Ljubjana) and Gordon Plotkin
(University of Edinburgh). This approach is gaining a lot of traction,
not only as a formalism but also as a practical feature in actual
programming languages (e.g.~the Koka language developed by Microsoft
Research). We are collaborating with Matija Pretnar on the efficient
implementation of one such language, called Eff. Axel Faes has
contributed to this collaboration during a project he did for the
Honoursprogramme of the Faculty of Engineering Science.

\section{Motivation}\label{motivation}

Algebraic effects and handlers benefit from a custom type-\&-effect
system, a type system that also tracks which effects can happen in a
program. Several such type-\&-effect systems have been proposed in the
literature, but all are unsatisfactory. We attribute this to the lack of
the elegant properties of Dolan's type system. Indeed the existing
type-\&-effect systems are not only theoretically unsatisfactory, but
they are also awkward to implement and use in practice.

\section{Research questions}\label{research-questions}

\begin{itemize}
\item How can Dolan's elegant type system be extended with effect information?
\item Which properties are preserved and which aren't preserved?
\item What advantages are there to an type-\&-effect system based on Dolan's elegant type system?
\end{itemize}

\section{Goals}\label{goals}

The goal of this thesis is to derive a type-\&-effect system that
extends Dolan's elegant type system with effect information. This
type-\&-effect system should inherit Dolan's harmonious combination of
subtyping (in our case induced by a lattice structure on the effect
information) with parametric polymorphism and preserve all of its
desirable properties (both low-level algebraic properties and high-level
meta-theoretical properties like type soundness and the existence of
principal types). Afterwards this type-\&-effect system The following
approach is taken:

\begin{enumerate}
\item Study of the relevant literature and theoretical background.
\item Design of a type-\&-effect system derived from Dolan's, that integrates effects.
\item Proving the desirable properties of the proposed type-\&-effect system: type soundness, principal typing, ...
\item Time permitting: Design of a type inference algorithm that derives the principal types of programs without type annotations and proving its correctness.
\item Time permitting: Implementation of the algorithm and comparing it to other algorithms (such as row polymorphism based type-\&-effect systems).
\end{enumerate}

\chapter{Background}\label{background}

\chapter{\texorpdfstring{Related Work
(\eff)}{Related Work ()}}\label{related-work}

The type-\&-effect system that is used in \eff is based on subtyping and
dirty types {[}1{]}.

\section{Types and terms}\label{types-and-terms}

\paragraph{Terms}

Figure\textasciitilde{}\ref{fig:terms:eff} shows the two types of terms
in \eff. There are values \(v\) and computations \(c\). Computations are
terms that can contain effects. Effects are denoted as operations \(Op\)
which can be called.

\paragraph{Types}

Figure\textasciitilde{}\ref{fig:types:eff} shows the types of \eff.
There are two main sorts of types. There are (pure) types \(A, B\) and
dirty types \(\C, \D\). A dirty type is a pure type \(A\) tagged with a
finite set of operations \(\dirt\), which we call dirt, that can be
called. This finite set \(\dirt\) is an over-approximation of the
operations that are actually called. The type \(\C \hto \D\) is used for
handlers because a handler takes an input computation \(\C\), handles
the effects in this computation and outputs computation \(\D\) as the
result.

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.98\columnwidth}
\[\begin{array}{r@{~}c@{~}l@{\quad}l}
  \text{value}~v & \bnfis {} & x & \text{variable} \\
    & \bnfor & \const & \text{constant} \\
    & \bnfor & \fun{x} c & \text{function} \\
    & \bnfor & \{ & \text{handler} \\
    & & \quad \ret x \mapsto c_r, & \quad\text{return case} \\
    & & \quad \shortcases & \quad\text{operation cases} \\
    & & \} & \\
  \text{comp}~c & \bnfis & v_1 \, v_2 & \text{application} \\
    & \bnfor & \letrecin{f \, x = c_1} c_2 & \text{rec definition} \\
    & \bnfor & \ret v  & \text{returned val} \\
    & \bnfor & \op \, v & \text{operation call} \\
    & \bnfor & \doin{x \leftarrow c_1} c_2 & \text{sequencing} \\
    & \bnfor & \withhandle{v}{c} & \text{handling}
\end{array}\]
\end{minipage}
}
\end{center}
\caption{Terms of \eff}\label{fig:terms:eff}
\end{figure}

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.98\columnwidth}
\[\begin{array}{r@{~}c@{~}l@{\quad}l}
  \text{(pure) type}~A, B & \bnfis {}
    & \boolty \bnfor \intty & \text{basic types} \\
    & \bnfor & A \to \C & \text{function type} \\
    & \bnfor & \C \hto \D & \text{handler type} \\
  \text{dirty type}~\C, \D & \bnfis {} & A \E \dirt \\
  \text{dirt}~\dirt & \bnfis {} &\set{\op_1, \dots, \op_n}
\end{array}\]
\end{minipage}
}
\end{center}
\caption{Types of \eff}\label{fig:types:eff}
\end{figure}

\section{Type System}\label{type-system}

\subsection{Subtyping}\label{subtyping}

The dirty type \(A \E \dirt\) is assigned to a computation returning
values of type \(A\) and potentially calling operations from the set
\(\dirt\). This set \(\dirt\) is always an over-approximation of the
actually called operations, and may safely be increased, inducing a
natural subtyping judgement \(A \E \dirt \leq A \E \dirt'\) on dirty
types. As dirty types can occur inside pure types, we also get a derived
subtyping judgement on pure types. Both judgements are defined in
Figure\textasciitilde{}\ref{fig:subtyping}. Observe that, as usual,
subtyping is contravariant in the argument types of functions and
handlers, and covariant in their return types.

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\textbf{Subtyping}
\begin{mathpar}
  \inferrule[Sub-$\boolty$]{
  }{
    \boolty \le \boolty
  }

  \inferrule[Sub-$\intty$]{
  }{
    \intty \le \intty
  }

  \inferrule[Sub-$\to$]{
    A' \le A \\
    \C \le \C'
  }{
    A \to \C \le A' \to \C'
  }

  \inferrule[Sub-$\hto$]{
    \C' \le \C \\
    \D \le \D'
  }{
    \C \hto \D \le \C' \hto \D'
  }

  \inferrule[Sub-$\E$]{
    A \le A' \\
    \dirt \subseteq \dirt'
  }{
    A \E \dirt \le A' \E \dirt'
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Subtyping for pure and dirty types of \eff}\label{fig:subtyping}
\end{figure}

\subsection{Typing rules}\label{typing-rules}

Figure\textasciitilde{}\ref{fig:eff-typing} defines the typing
judgements for values and computations with respect to a standard typing
context \(\ctx\).

\paragraph{Values}

The rules for subtyping, variables, and functions are entirely standard.
For constants we assume a signature \(\sig\) that assigns a
type\textasciitilde{}\(A\) to each constant\textasciitilde{}\(\const\),
which we write as \((\const \T A) \in \sig\).

A handler expression has type \(A \E \dirt \cup \ops \hto B \E \dirt\)
iff all branches (both the operation cases and the return case) have
dirty type \(B \E \dirt\) and the operation cases cover the set of
operations \(\ops\). Note that the intersection \(\dirt \cap \ops\) is
not necessarily empty. The handler deals with the operations \(\ops\),
but in the process may re-issue some of them (i.e.,
\(\dirt \cap \ops\)).

When typing operation cases, the given signature for the operation
\((\op \T A_\op \to B_\op) \in \sig\) determines the type \(A_\op\) of
the parameter \(x\) and the domain \(B_\op\) of the continuation \(k\).
As our handlers are deep, the codomain of \(k\) should be the same as
the type \(B \E \dirt\) of the cases.

\paragraph{Computations}

With the following exceptions, the typing judgement \(\ctx \ent c : \C\)
has a straightforward definition. The \(\ret\) construct renders a value
\(v\) as a pure computation, i.e., with empty dirt. An operation
invocation \(\op\,v\) is typed according to the operation's signature,
with the operation itself as its only operation. Finally, rule
\textsc{With} shows that a handler with type \(\C \hto \D\) transforms a
computation with type \(\C\) into a computation with type \(\D\).

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\[\begin{array}{r@{~}c@{~}l}
  \text{typing contexts}~\ctx & \bnfis {} & \epsilon \bnfor \ctx, x : A\\
\end{array}\]
\textbf{Expressions}
\begin{mathpar}
  \inferrule[SubVal]{
    \ctx \ent v \T A \\
    A \le A'
  }{
    \ctx \ent v \T A'
  }

  \inferrule[Var]{
    (x \T A) \in \ctx
  }{
    \ctx \ent x \T A
  }

  \inferrule[Const]{
    (\const \T A) \in \sig
  }{
    \ctx \ent \const \T A
  }

  \inferrule[Fun]{
    \ctx, x \T A \ent c \T \C
  }{
    \ctx \ent \fun{x} c \T A \to \C
  }

  \inferrule[Hand]{
    \ctx, x \T A \ent c_r \T B \E \dirt \\
    \Big[
      (\op \T A_\op \to B_\op) \in \sig \qquad \\
      \ctx, x \T A_\op, k \T B_\op \to B \E \dirt \ent c_\op \T B \E \dirt
    \Big]_{\op \in \ops}
  }{
    \ctx \ent \shorthand \T \\ A \E \dirt \cup \ops \hto B \E \dirt
  }
\end{mathpar}
\textbf{Computations}
\begin{mathpar}
  \inferrule[SubComp]{
    \ctx \ent c \T \C \\
    \C \le \C'
  }{
    \ctx \ent c \T \C'
  }

  \inferrule[App]{
    \ctx \ent v_1 \T A \to \C \\
    \ctx \ent v_2 \T A
  }{
    \ctx \ent v_1 \, v_2 \T \C
  }

 \inferrule[LetRec]{
    \ctx, f \T A \to \C, x \T A \ent c_1 \T \C \\
    \ctx, f \T A \to \C \ent c_2 \T \D
  }{
    \ctx \ent \letrecin{f \, x = c_1} c_2 \T \D
  }

  \inferrule[Ret]{
    \ctx \ent v \T A
  }{
    \ctx \ent \ret v \T A \E \emptyset
  }

  \inferrule[Op]{
    (\op \T A \to B) \in \sig \\
    \ctx \ent v \T A
  }{
    \ctx \ent \op \, v \T B \E \{\op\}
  }

  \inferrule[Do]{
    \ctx \ent c_1 \T A \E \dirt \\
    \ctx, x \T A \ent c_2 \T B \E \dirt
  }{
    \ctx \ent \doin{x \leftarrow c_1} c_2 \T B \E \dirt
  }

  \inferrule[With]{
    \ctx \ent v \T \C \hto \D \\
    \ctx \ent c \T \C
  }{
    \ctx \ent \withhandle{v}{c} \T \D
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Typing of \eff}\label{fig:eff-typing}
\end{figure}

\chapter{Problem Statement}\label{problem-statement}

\chapter{Planning}\label{planning}

\chapter{\texorpdfstring{Core language
(\core)}{Core language ()}}\label{core-language}

\core is a language with row-based effects, intersection and union types
and effects and is subtyping based.

\section{Types and terms}\label{types-and-terms-1}

\paragraph{Terms}

Figure\textasciitilde{}\ref{fig:terms:core} shows the two types of terms
in \core. There are values \(v\) and computations \(c\). Computations
are terms that can contain effects. Effects are denoted as operations
\(Op\) which can be called. The function term is explicitly annotated
with a type and type abstraction and type application has been added to
the language. These terms only work on pure types.

\paragraph{Types}

Figure\textasciitilde{}\ref{fig:types:core} shows the types of \core.
There are two main sorts of types. There are (pure) types \(A, B\) and
dirty types \(\C, \D\). A dirty type is a pure type \(A\) tagged with a
finite set of operations \(\dirt\), which we call dirt, that can be
called. It can also be an union or intersection of dirty types. In
further sections, the relations between dirty intersections or unions
and pure intersections or unions are explained. The finite set \(\dirt\)
is an over-approximation of the operations that are actually called. Row
variables are introduced as well as intersection and unions. The
\(\dirtend\) is used to close rows that do not end with a row variable.
The type \(\C \hto \D\) is used for handlers because a handler takes an
input computation \(\C\), handles the effects in this computation and
outputs computation \(\D\) as the result.

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.98\columnwidth}
\[\begin{array}{r@{~}c@{~}l@{\quad}l}
  \text{value}~v & \bnfis {} & x & \text{variable} \\
    & \bnfor & \const & \text{constant} \\
    & \bnfor & \funtyped{x}{A}{c} & \text{function} \\
    & \bnfor & \Lambda \alpha . v & \text{type abstraction} \\
    & \bnfor & v \, A & \text{type application} \\
    & \bnfor & \{ & \text{handler} \\
    & & \quad \ret x \mapsto c_r, & \quad\text{return case} \\
    & & \quad \shortcases & \quad\text{operation cases} \\
    & & \} & \\
  \text{comp}~c & \bnfis & v_1 \, v_2 & \text{application} \\
    & \bnfor & \conditional{e}{c_1}{c_2} & \text{conditional} \\
    & \bnfor & \letrecin{f \, x = c_1} c_2 & \text{rec definition} \\
    & \bnfor & \ret v  & \text{returned val} \\
    & \bnfor & \op \, v & \text{operation call} \\
    & \bnfor & \doin{x \leftarrow c_1} c_2 & \text{sequencing} \\
    & \bnfor & \withhandle{v}{c} & \text{handling}
\end{array}\]
\end{minipage}
}
\end{center}
\caption{Terms of \core}\label{fig:terms:core}
\end{figure}

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.98\columnwidth}
\[\begin{array}{r@{~}c@{~}l@{\quad}l}
  \text{(pure) type}~A, B & \bnfis {}
    & \boolty \bnfor \intty & \text{basic types} \\
    & \bnfor & A \to \C & \text{function type} \\
    & \bnfor & \C \hto \D & \text{handler type} \\
    & \bnfor & \alpha & \text{type variable} \\
    & \bnfor & \polytype{A} & \text{polytype} \\
    & \bnfor & \top & \text{top} \\
    & \bnfor & \bot & \text{bottom} \\
    & \bnfor & A \intersection B & \text{intersection} \\
    & \bnfor & A \union B & \text{union} \\
  \text{dirty type}~\C, \D & \bnfis {} & A \E \dirt \\
    & \bnfor & \C \intersection \D & \text{intersection} \\
    & \bnfor & \C \union \D & \text{union} \\
  \text{dirt}~\dirt & \bnfis {} & \{\text{R}\} \\
  \text{R} & \bnfis {}
    & \op \row & \text{row} \\
    & \bnfor & \delta & \text{row variable} \\
    & \bnfor & . & \text{closed row} \\
    & \bnfor & \delta_1 \intersection \delta_2 & \text{\textbf{row intersection}} \\
    & \bnfor & \delta_1 \union \delta_2 & \text{\textbf{row union}} \\
    & \bnfor & R_1 \intersection R_2 & \text{intersection} \\
    & \bnfor & R_1 \union R_2 & \text{union}
\end{array}\]
\end{minipage}
}
\end{center}
\caption{Types of \core}\label{fig:types:core}
\end{figure}

\section{Type system}\label{type-system-1}

\subsection{Subtyping}\label{subtyping-1}

The subtyping rules are given in
Figure\textasciitilde{}\ref{fig:core-subtyping},
Figure\textasciitilde{}\ref{fig:core-subtyping-dist} and
Figure\textasciitilde{}\ref{fig:core-subtyping-dirt}.
Figure\textasciitilde{}\ref{fig:core-subtyping} contains all subtyping
rules related to types.
Figure\textasciitilde{}\ref{fig:core-subtyping-dist} contains the
distributative subtyping rules. Finally
Figure\textasciitilde{}\ref{fig:core-subtyping-dirt} contains the
subtyping rules that govern the dirts.

The dirty type \(A \E \dirt\) is assigned to a computation returning
values of type \(A\) and potentially calling operations from the set
\(\dirt\). This set \(\dirt\) is always an over-approximation of the
actually called operations, and may safely be increased, inducing a
natural subtyping judgement \(A \E \dirt \leq A \E \dirt'\) on dirty
types. As dirty types can occur inside pure types, we also get a derived
subtyping judgement on pure types. Observe that, as usual, subtyping is
contravariant in the argument types of functions and handlers, and
covariant in their return types.

\paragraph{Dirt intersection and union}

There are several possible methods to compute the dirt intersection and
union. If row variables were to be disregarded, dirt union and
intersection could be defined as set union and intersection. This
methods allows unions and intersections to be eliminated. This has an
advantage, eliminating unions and intersections simplifies the effect
system. However, we cannot disregard row variables.

Thus, set union and intersection cannot simply be used. It would be
possible to define two extra types, namely \(\delta_1 \union \delta_2\)
and \(\delta_1 \intersection \delta_2\). Using these types, it is
possible to use a form of set union and intersection. The following
union
\(\{Op_1, ..., Op_n, \delta_1\} \union \{Op_{n+1}, ..., Op_{n+m}, \delta_2\}\)
could be defined as
\(\{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, (\delta_1 \union \delta_2)\}\).
A similar construction can be used for intersection. This simplifies the
subtyping rules since the more complicated aspects are enclosed within
the row variables.

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\textbf{Subtyping of pure and dirty types}
\begin{mathpar}
  \inferrule[Sub-Top]{
  }{
    A \le \top
  }

  \inferrule[Sub-Bottom]{
  }{
    \bot \le A
  }
  \\

  \inferrule[Sub-$\boolty$]{
  }{
    \boolty \le \boolty
  }

  \inferrule[Sub-$\intty$]{
  }{
    \intty \le \intty
  }
  \\

  \inferrule[Sub-Refl]{
  }{
    A \le A
  }

  \inferrule[Sub-Trans]{
    A_1 \le A_2 \\
    A_2 \le A_3
  }{
    A_1 \le A_3
  }
  \\

  \inferrule[Sub-$\E$]{
    A_1 \le A'_2 \\
    \dirt_1 \le \dirt'_2
  }{
    A_1 \E \dirt_1 \le A_2 \E \dirt_2
  }

  \inferrule[Sub-All]{
    A \le B
  }{
   \polytype{A} \le \polytype{B}
  }
  \\

  \inferrule[Sub-$\to$]{
    A_2 \le A_1 \\
    \C_1 \le \C_2
  }{
    A_1 \to \C_1 \le A_2 \to \C_2
  }

  \inferrule[Sub-$\hto$]{
    \C_2 \le \C_1 \\
    \D_1 \le \D_2
  }{
    \C_1 \hto \D_1 \le \C_2 \hto \D_2
  }
  \\
  \inferrule[Sub-Inter]{
    A_1 \le A_2 \\
    B_1 \le B_2 \\
  }{
    A_1 \intersection B_1 \le A_2 \intersection B_2
  }

  \inferrule[Sub-Union]{
    A_1 \le A_2 \\
    B_1 \le B_2 \\
  }{
    A_1 \union B_1 \le A_2 \union B_2
  }

  \inferrule[Sub-Inter-G]{
    A \le B_1 \\
    A \le B_2 \\
  }{
    A \le B_1 \intersection B_2
  }

  \inferrule[Sub-Inter-LB]{
    i \in \{1; 2\}
  }{
    A_1 \intersection A_2 \le A_i
  }

  \inferrule[Sub-Union-L]{
    B_1 \le A \\
    B_2 \le A \\
  }{
    B_1 \union B_2 \le A
  }

  \inferrule[Sub-Inter-UB]{
    i \in \{1; 2\}
  }{
    A_i \le A_1 \union A_2
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Subtyping for pure and dirty types of \core}\label{fig:core-subtyping}
\end{figure}

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\textbf{Distributivity Subtyping of pure and dirty types}
\begin{mathpar}
  \inferrule[Sub-Dist-Func-Inter]{
  }{
    (A \to \C) \intersection (A \to \D) \le A \to (\C \intersection \D)
  }

  \inferrule[Sub-Dist-Func-Union]{
  }{
    (A \to \C) \intersection (B \to \C) \le (A \union B) \to \C
  }

  \inferrule[Sub-Dist-Hand-Inter]{
  }{
    (A \hto \C) \intersection (A \hto \D) \le A \hto (\C \intersection \D)
  }

  \inferrule[Sub-Dist-Hand-Union]{
  }{
    (A \hto \C) \intersection (B \hto \C) \le (A \union B) \hto \C
  }

  \inferrule[Sub-Dist-All]{
  }{
    \polytype{A} \intersection \polytype{B} \le \polytype{A \intersection B}
  }

  \inferrule[Sub-Inter-Union]{
  }{
    (A_1 \intersection A_3) \union (A_2 \intersection A_4) \le (A_1 \union A_2) \intersection (A_3 \union A_4)
  }

  \inferrule[Sub-Union-Inter]{
  }{
    (A_1 \union A_3) \intersection (A_2 \union A_4) \le (A_1 \intersection A_2) \union (A_3 \intersection A_4)
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Distributivity Subtyping for pure and dirty types of \core}\label{fig:core-subtyping-dist}
\end{figure}

\begin{figure}[h!]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\textbf{Subtyping of dirts}
\begin{mathpar}
  \inferrule[Sub-$\E$-Empty]{
  }{
    \emptyrow \le \dirt
  }

  \inferrule[Sub-$\E$-Top]{
  }{
     \{Op_1, ..., Op_n, .\} \le \{Op_1, ..., Op_n, \delta\}
  }
  \\

  \inferrule[Sub-$\E$-Refl]{
  }{
     \dirt \le \dirt
  }

  \inferrule[Sub-$\E$-Trans]{
    \dirt_1 \le \dirt_2 \\
    \dirt_2 \le \dirt_3
  }{
     \dirt_1 \le \dirt_3
  }
  \\

  \inferrule[Sub-$\E$-Row-Row]{
    n \ge 0 \\
    m \ge 0 \\
    p \ge 0 \\
    \{Op_1, ..., Op_{n}, Op_{n+m+1}, ..., Op_{n+m+p}, \delta_1\} \le \\ \{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, \delta_2\}
  }{
    \{\delta_1\} \le \{Op_{n+1}, ..., Op_{n+m}, \delta_2\} \\
    Op_{n+m}, ..., Op_{n+m+p} \subseteq \delta_2
  }

  \inferrule[Sub-$\E$-Dot-Row]{
    n \ge 0 \\
    m \ge 0 \\
    p \ge 0 \\
    \{Op_1, ..., Op_{n}, Op_{n+m+1}, ..., Op_{n+m+p}, .\} \le \\ \{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, \delta_2\}
  }{
    \emptyrow \le \{Op_{n+1}, ..., Op_{n+m}, \delta_2\} \\
    Op_{n+m}, ..., Op_{n+m+p} \subseteq \delta_2
  }

  % \inferrule[Sub-$\E$-Row-Row]{
  %   n \ge 0 \\
  %   m \ge 0 \\
  %   \{Op_1, ..., Op_n, \delta_1\} \le \{Op_1, ..., Op_n, Op_{n+1}, Op_{n+m}, \delta_2\}
  % }{
  %   \{\delta_1\} \le \{Op_{n+1}, Op_{n+m}, \delta_2\}
  % }

  \inferrule[Sub-$\E$-Row-Dot]{
    n \ge 0 \\
    m \ge 0 \\
    \{Op_1, ..., Op_n, \delta_1\} \le \{Op_1, ..., Op_n, Op_{n+1}, Op_{n+m}, .\}
  }{
    \{\delta_1\} \le \{Op_{n+1}, Op_{n+m}, .\}
  }

  % \inferrule[Sub-$\E$-Dot-Row]{
  %   n \ge 0 \\
  %   m \ge 0 \\
  %   \{Op_1, ..., Op_n, .\} \le \{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, \delta_2\}
  % }{
  %   \emptyrow \le \{Op_{n+1}, Op_{n+m}, \delta_2\}
  % }

  \inferrule[Sub-$\E$-Dot-Dot]{
    n \ge 0 \\
    m \ge 0 \\
    \{Op_1, ..., Op_n, .\} \le \{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, .\}
  }{
    \emptyrow \le \{Op_{n+1}, Op_{n+m}, .\}
  }

  \inferrule[Sub-Inter-$\E$]{
    \dirt_1 \le \dirt_2 \\
    \dirt_3 \le \dirt_4 \\
  }{
    \dirt_1 \intersection \dirt_3 \le \dirt_2 \intersection \dirt_4
  }

  \inferrule[Sub-Union-$\E$]{
    \dirt_1 \le \dirt_2 \\
    \dirt_3 \le \dirt_4 \\
  }{
    \dirt_1 \union \dirt_3 \le \dirt_2 \union \dirt_4
  }

  \inferrule[Sub-Inter-G-$\E$]{
    \dirt_1 \le \dirt_2 \\
    \dirt_1 \le \dirt_3
  }{
    \dirt_1 \le (\dirt_2 \intersection \dirt_3)
  }

  \inferrule[Sub-Inter-LB-$\E$]{
    i \in \{1; 2\}
  }{
    (\dirt_1 \intersection \dirt_2) \le \dirt_i
  }

  \inferrule[Sub-Union-L-$\E$]{
    \dirt_2 \le \dirt_1 \\
    \dirt_3 \le \dirt_1
  }{
    (\dirt_2 \union \dirt_3) \le \dirt_1
  }

  \inferrule[Sub-Union-UB-$\E$]{
    i \in \{1; 2\}
  }{
    \dirt_i \le (\dirt_1 \union \dirt_2)
  }

  \inferrule[Sub-Inter-Union-$\E$]{
  }{
    (\dirt_1 \intersection \dirt_3) \union (\dirt_2 \intersection \dirt_4) \le (\dirt_1 \union \dirt_2) \intersection (\dirt_3 \union \dirt_4)
  }

  \inferrule[Sub-Union-Inter-$\E$]{
  }{
    (\dirt_1 \union \dirt_3) \intersection (\dirt_2 \union \dirt_4) \le (\dirt_1 \intersection \dirt_2) \union (\dirt_3 \intersection \dirt_4)
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Subtyping for dirts of \core}\label{fig:core-subtyping-dirt}
\end{figure}

\begin{figure}[h!]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\textbf{Subtyping of dirts}
\begin{mathpar}
  \inferrule[Sub-$\E$-Empty]{
  }{
    . \le \delta
  }

  \inferrule[Sub-$\E$-Refl]{
  }{
     \delta \le \delta
  }

  \inferrule[Sub-$\E$-Trans]{
    \delta_1 \le \delta_2 \\
    \delta_2 \le \delta_3
  }{
     \delta_1 \le \delta_3
  }

  \inferrule[Sub-Inter-$\E$]{
    \delta_1 \le \delta_2 \\
    \delta_3 \le \delta_4 \\
  }{
    \delta_1 \intersection \delta_3 \le \delta_2 \intersection \delta_4
  }

  \inferrule[Sub-Union-$\E$]{
    \delta_1 \le \delta_2 \\
    \delta_3 \le \delta_4 \\
  }{
    \delta_1 \union \delta_3 \le \delta_2 \union \delta_4
  }

  \inferrule[Sub-Inter-G-$\E$]{
    \delta_1 \le \delta_2 \\
    \delta_1 \le \delta_3
  }{
    \delta_1 \le (\delta_2 \intersection \delta_3)
  }

  \inferrule[Sub-Inter-LB-$\E$]{
    i \in \{1; 2\}
  }{
    (\delta_1 \intersection \delta_2) \le \delta_i
  }

  \inferrule[Sub-Union-L-$\E$]{
    \delta_2 \le \delta_1 \\
    \delta_3 \le \delta_1
  }{
    (\delta_2 \union \delta_3) \le \delta_1
  }

  \inferrule[Sub-Union-UB-$\E$]{
    i \in \{1; 2\}
  }{
    \delta_i \le (\delta_1 \union \delta_2)
  }

  \inferrule[Sub-Inter-Union-$\E$]{
  }{
    (\delta_1 \intersection \delta_3) \union (\delta_2 \intersection \delta_4) \le (\delta_1 \union \delta_2) \intersection (\delta_3 \union \delta_4)
  }

  \inferrule[Sub-Union-Inter-$\E$]{
  }{
    (\delta_1 \union \delta_3) \intersection (\delta_2 \union \delta_4) \le (\delta_1 \intersection \delta_2) \union (\delta_3 \intersection \delta_4)
  }

  \inferrule[Dirt-Var-Union-$\E$]{
  }{
     \{Op_1, ..., Op_n, Op_{n+1}, ..., Op_{n+m}, (\delta_1 \union \delta_2)\} \le\\
     \{Op_1, ..., Op_n, \delta_1\} \union \{Op_{n+1}, ..., Op_{n+m}, \delta_2\}
  }

  \inferrule[Dirt-Var-Intersection-$\E$]{
  }{
    \{Op_i | Op_i \in \{Op_1, ..., Op_n\} \land \\Op_i \in \{Op_{n+1}, ..., Op_{n+m}\}, (\delta_1 \intersection \delta_2)\} \le\\
    \{Op_1, ..., Op_n, \delta_1\} \intersection \{Op_{n+1}, ..., Op_{n+m}, \delta_2\}
  }

\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Subtyping for dirts of \core using row variable unions and intersections}\label{fig:core-subtyping-dirt2}
\end{figure}

\subsection{Typing rules}\label{typing-rules-1}

Figure\textasciitilde{}\ref{fig:core-typing} defines the typing
judgements for values and computations with respect to a standard typing
context \(\ctx\).

\paragraph{Values}

The rules for subtyping, variables, type abstraction, type application
and functions are entirely standard. For constants we assume a signature
\(\sig\) that assigns a type\textasciitilde{}\(A\) to each
constant\textasciitilde{}\(\const\), which we write as
\((\const \T A) \in \sig\).

A handler expression has type \(A \E \dirt \cup \ops \hto B \E \dirt\)
iff all branches (both the operation cases and the return case) have
dirty type \(B \E \dirt\) and the operation cases cover the set of
operations \(\ops\). Note that the intersection \(\dirt \cap \ops\) is
not necessarily empty (with \(\cap\) being the intersection of the
operations, not to be confused with the \(\intersection\) type). The
handler deals with the operations \(\ops\), but in the process may
re-issue some of them (i.e., \(\dirt \cap \ops\)).

When typing operation cases, the given signature for the operation
\((\op \T A_\op \to B_\op) \in \sig\) determines the type \(A_\op\) of
the parameter \(x\) and the domain \(B_\op\) of the continuation \(k\).
As our handlers are deep, the codomain of \(k\) should be the same as
the type \(B \E \dirt\) of the cases.

\paragraph{Computations}

With the following exceptions, the typing judgement \(\ctx \ent c : \C\)
has a straightforward definition. The \(\ret\) construct renders a value
\(v\) as a pure computation, i.e., with empty dirt. In this case, this
is defined as a set with the \(\dirtend\) as the only element. An
operation invocation \(\op\,v\) is typed according to the operation's
signature, with the operation itself as its only operation. Finally,
rule \textsc{With} shows that a handler with type \(\C \hto \D\)
transforms a computation with type \(\C\) into a computation with type
\(\D\).

\begin{figure}[h]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\[\begin{array}{r@{~}c@{~}l}
  \text{typing contexts}~\ctx & \bnfis {} & \epsilon \bnfor \ctx, x : A\\
\end{array}\]
\textbf{Expressions}
\begin{mathpar}
  \inferrule[Val]{
    \ctx \ent v \T A \\
    A \le B
  }{
    \ctx \ent v \T B
  }

  \inferrule[Var]{
    (x \T A) \in \ctx
  }{
    \ctx \ent x \T A
  }

  \inferrule[Const]{
    (\const \T A) \in \sig
  }{
    \ctx \ent \const \T A
  }

  \inferrule[Type Abs]{
    \ctx, \alpha \ent v \T A
  }{
    \ctx \ent \Lambda \alpha . v \T \polytype{A}
  }

  \inferrule[Type App]{
    \ctx \ent v \T \polytype{B}
  }{
    \ctx \ent v \, A \T B[A/\alpha]
  }

  \inferrule[Fun]{
    \ctx, x \T A \ent c \T \C
  }{
    \ctx \ent \funtyped{x}{A}{c} \T A \to \C
  }

  % \inferrule[Hand]{
  %     \C = A \E \{Op_i \row\} \\
  %     \D = B \E \{Op_i \row\} \\
  %     (\op_i \T A_\op \to B_\op) \in \sig \qquad \\
  %     h = \shorthand \\
  %     \ctx, x \T A_\op \ent c_r \T \D \\
  %     \ctx, y \T A_\op, k \T B_\op \to \D \ent c_{op} \T \D \\
  % }{
  %     \ctx \ent h \T \C \hto \D
  % }

  \inferrule[Hand]{
    \ctx, x \T A \ent c_r \T B \E \dirt \\
    \Big[
      (\op \T A_\op \to B_\op) \in \sig \qquad \\
      \ctx, x \T A_\op, k \T B_\op \to B \E \dirt \ent c_\op \T B \E \dirt
    \Big]_{\op \in \ops}
  }{
    \ctx \ent \shorthand \T \\ A \E \dirt \cup \ops \hto B \E \dirt
  }

\end{mathpar}
\textbf{Computations}
\begin{mathpar}
  \inferrule[Comp]{
    \ctx \ent c \T \C \\
    \C \le \D
  }{
    \ctx \ent c \T \D
  }

  \inferrule[App]{
    \ctx \ent v_1 \T A \to \C \\
    \ctx \ent v_2 \T A
  }{
    \ctx \ent v_1 \, v_2 \T \C
  }

  \inferrule[Cond]{
    \ctx \ent v \T A \\
    \ctx \ent c_1 \T \C \\
    \ctx \ent c_2 \T \D \\
  }{
    \ctx \ent \conditional{v}{c_1}{c_2} \T (\C \union \D)
  }

 \inferrule[LetRec]{
    \ctx, f \T A \to \C, x \T A \ent c_1 \T \C \\
    \ctx, f \T A \to \C \ent c_2 \T \D
  }{
    \ctx \ent \letrecin{f \, x = c_1} c_2 \T \D
  }

  \inferrule[Ret]{
    \ctx \ent v \T A
  }{
    \ctx \ent \ret v \T A \E \emptyrow
  }

  \inferrule[Op]{
    (\op \T A \to B) \in \sig \\
    \ctx \ent v \T A \\
    \C \T B \E \{\op \row\}
  }{
    \ctx \ent \op \, v \T \C
  }

  \inferrule[Do]{
    \ctx \ent c_1 \T A \E \dirt \\
    \ctx, x \T A \ent c_2 \T B \E \dirt
  }{
    \ctx \ent \doin{x \leftarrow c_1} c_2 \T B \E \dirt
  }

  \inferrule[With]{
    \ctx \ent v \T \C \hto \D \\
    \ctx \ent c \T \C
  }{
    \ctx \ent \withhandle{v}{c} \T \D
  }

\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Typing of \core}\label{fig:core-typing}
\end{figure}

\chapter{Type Inference}\label{type-inference}

The elaboration show how the source language can be transformed into
\core.

\begin{figure}
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\[\begin{array}{r@{~}c@{~}l}
  \text{typing contexts}~\ctx & \bnfis {} & \epsilon \bnfor \ctx, x : A\\
\end{array}\]
\textbf{Expressions}
\begin{mathpar}
  \inferrule[Val]{
  }{
    \ctx \ent v \T A \leadsto v'
  }

  \inferrule[Var]{
    (x \T S) \in \ctx \\
    S = \forall \bar{\alpha} . A
  }{
    \ctx \ent x \T A[\bar{S}/\bar{\alpha}] \leadsto x \, \bar{S'}
  }

  \inferrule[Const]{
    (\const \T A) \in \sig
  }{
    \ctx \ent \const \T A \leadsto \const'
  }

  \inferrule[Fun]{
    \ctx, x \T A \ent c \T \C \leadsto c'
  }{
    \ctx \ent \fun{x} c \T A \to \C \leadsto \lambda (x \T A) . c' \T A \to \C
  }

  % \inferrule[Hand]{
  %   \ctx, x \T A \ent c_r \T B \E \dirt \\
  %   \Big[
  %     (\op \T A_\op \to B_\op) \in \sig \qquad \\
  %     \ctx, x \T A_\op, k \T B_\op \to B \E \dirt \ent c_\op \T B \E \dirt
  %   \Big]_{\op \in \ops}
  % }{
  %   \ctx \ent \shorthand \T \\ A \E \dirt \cup \ops \hto B \E \dirt
  % }

  \inferrule[Hand]{
    \C = A \E \{Op_i \row\} \\
    \D = B \E \{Op_i \row\} \\
    (\op_i \T A_\op \to B_\op) \in \sig \qquad \\
    h = \shorthand \\ \leadsto h' = \shorthandelab \\
    \ctx, x \T A_\op \ent c_r \T \D \leadsto c'_r \T \D \\
    \ctx, y \T A_\op, k \T B_\op \to \D \ent c_{op} \T \D \leadsto c'_{op} \T \D\\
  }{
    \ctx \ent h \T \C \hto \D \leadsto h' \T \C \hto \D
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Elaboration of source to core language: expressions}\label{fig:elaboration:exp}
\end{figure}

\begin{figure}
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
\[\begin{array}{r@{~}c@{~}l}
  \text{typing contexts}~\ctx & \bnfis {} & \epsilon \bnfor \ctx, x : A\\
\end{array}\]
\textbf{Computations}
\begin{mathpar}
  \inferrule[Comp]{
  }{
    \ctx \ent c \T \C' \leadsto c'
  }

  \inferrule[App]{
    \ctx \ent v_1 \T A \to \C \leadsto v'_1 \\
    \ctx \ent v_2 \T A \leadsto v'_2
  }{
    \ctx \ent v_1 \, v_2 \T \C \leadsto v'_1 \, v'_2 \T \C
  }

 \inferrule[LetRec]{
    \ctx, f \T A \to \C, x \T A \ent c_1 \T \C \leadsto c'_1 s\\
    \ctx, f \T A \to \C \ent c_2 \T \D \leadsto c'_2
  }{
    \ctx \ent \letrecin{f \, x = c_1} c_2 \T \D \\ \leadsto \letrecin{f \, x = c'_1} c'_2 \T \D
  }

  \inferrule[Ret]{
    \ctx \ent v \T A \leadsto v'
  }{
    \ctx \ent \ret v \T A \E \emptyset \leadsto \ret v' \T A \E \emptyset
  }

  \inferrule[Op]{
    (\op \T A \to B) \in \sig \\
    \C = B \E \{\op \row \} \\
    \ctx \ent v \T A \leadsto v'
  }{
    \ctx \ent \op \, v \T \C \leadsto \op \, v' \T \C
  }

  \inferrule[Do]{
    \ctx \ent c_1 \T \C \leadsto c'_1 \\
    S = \forall \bar{\alpha} . A \\
    \bar{\alpha} = FTV(A) - TV(\ctx) \\
    \ctx, x \T S \ent \D \leadsto c'_2
  }{
    \ctx \ent \doin{x \leftarrow c_1} c_2 \T \D \leadsto (\lambda (x \T A) . c'_2) (\Lambda \bar{\alpha} . c'_1)
  }

  \inferrule[With]{
    \ctx \ent v \T \C \hto \D \leadsto v' \\
    \ctx \ent c \T \C \leadsto c'
  }{
    \ctx \ent \withhandle{v}{c} \T \D \leadsto \withhandle{v'}{c'} \T \D
  }
\end{mathpar}
\end{minipage}
}
\end{center}
\caption{Elaboration of source to core language: computations}\label{fig:elaboration:comp}
\end{figure}

\chapter{Semantics}\label{semantics}

\chapter{Proofs}\label{proofs}

\chapter{Implementation}\label{implementation}

\chapter{Evaluation}\label{evaluation}

\chapter*{Conclusion}\label{conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

\hypertarget{refs}{}
\hypertarget{ref-effectsystem}{}
{[}1{]} Bauer, A. and Pretnar, M. 2014. An effect system for algebraic
effects and handlers. \emph{Logical Methods in Computer Science}. 10, 4
(2014). DOI:\url{https://doi.org/10.2168/LMCS-10(4:9)2014}.

\backmatter

\bibliographystyle{abbrv}
\bibliography{/Users/axelfaes/GoogleDrive/workspace/projects/algebraic-subtyping-for-algebraic-effects-and-handlers/thesis/bib/references.bib}


\end{document}
