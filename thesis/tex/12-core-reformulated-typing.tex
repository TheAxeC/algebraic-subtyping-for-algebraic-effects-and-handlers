\subsection{Reformulated typing rules}

\begin{figure}[!htb]
  \begin{center}
  \begin{framed}
  \begin{minipage}[t]{0.95\columnwidth}
  \begin{mathpar}    
      \inferrule[$\ctxm$Def]{}{
        \ctxm \text{ contains free $\lambda$-bound variables}
      }\\

      \inferrule[SubScheme]{}{
        [\ctxm_2]A_2 \le [\ctxm_1]A_1 \leftrightarrow A_2 \le A_1, \ctxm_1 \le \ctxm_2
      }\\
  
      \inferrule[SubInst]{}{
        [\ctxm_2]A_2 \le^\forall [\ctxm_1]A_1 \leftrightarrow \rho([\ctxm_2]A_2) \le [\ctxm_1]A_1 \text{for some substitution }\rho \\\text{ (instantiate type + dirt vars)}
      }\\

      \inferrule[Inter]{
        dom(\ctxm_1 \intersection \ctxm_2) = dom(\ctxm_1) \cup dom(\ctxm_2) \\
        (\ctxm_1 \intersection \ctxm_2)(x) = \ctxm_1(x) \intersection \ctxm_2(x) \text{, interpreting } \ctxm_i(x) = \top \text{ if } x \in dom(\ctxm_i) \text{ (for } i \in \{1, 2\} \text{)}
      }{
        \ctxm_1 \text{ and } \ctxm_2 \text{ have greatest lower bound: } \ctxm_1 \intersection \ctxm_2
      }\\

      \inferrule[SubstEq]{}{
        \rho([\ctxm]A) \equiv [\rho(\ctxm)]\rho(A)
      }\\

      \inferrule[Eq]{}{
        [\ctxm_2]A_2 \equiv^\forall [\ctxm_1]A_1 \leftrightarrow [\ctxm_2]A_2 \le^\forall [\ctxm_1]A_1, [\ctxm_1]A_1 \le^\forall [\ctxm_2]A_2
      }\\

      \inferrule[WeakeningMono]{}{
        \ctxm_2 \le^\forall \ctxm_1 \leftrightarrow dom(\ctxm_2) \supseteq dom(\ctxm_1), \ctxm_2(x) \le^\forall \ctxm_1(x) \text{ | } x \in dom(\ctxm_1)
      }\\

      \inferrule[WeakeningPoly]{}{
        \ctxp_2 \le^\forall \ctxp_1 \leftrightarrow dom(\ctxp_2) \supseteq dom(\ctxp_1), \ctxp_2(\letvar) \le^\forall \ctxp_1(\letvar) \text{ | } \letvar \in dom(\ctxp_1)
      }
  \end{mathpar}
  \end{minipage}
  \end{framed}
  \end{center}
\caption{Definitions for typing schemes and reformulated typing rules}\label{fig:core-scheme}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\framebox{
\begin{minipage}{0.95\columnwidth}
    \[\begin{array}{r@{~}c@{~}l}
      \text{monomorphic typing contexts}~\ctxm & \bnfis {} & \epsilon \bnfor \ctxm, x : A\\
      \text{polymorphic typing contexts}~\ctxp & \bnfis {} & \epsilon \bnfor \ctxp, \letvar : [\ctxm]A\\
    \end{array}\]
    \textbf{Expressions}
    \begin{mathpar}
      \inferrule[SubVal]{
        \ctxp \entt v \T [\ctxm_1]A_1 \\
        [\ctxm_1]A_1 \le^\forall [\ctxm_2]A_2
      }{
        \ctxp \entt v \T [\ctxm_2]A_2
      }
    
      \inferrule[Var-$\ctxm$]{
      }{
        \ctxp \entt x \T [x : A]A
      }
    
      \inferrule[Var-$\ctxp$]{
        (\letvar \T [\ctxm]A) \in \ctxp
      }{
        \ctxp \entt \letvar \T [\ctxm]A
      }    
    
      \inferrule[True]{
      }{
        \ctxp \entt \tru \T []bool
      }
    
      \inferrule[False]{
      }{
        \ctxp \entt \fls \T []bool
      }
    
      \inferrule[Fun]{
        \ctxp \entt c \T [\ctxm, x \T A]\C
      }{
        \ctxp \entt \fun{x}c \T [\ctxm](A \to \C)
      }
    
      \inferrule[Hand]{
        \ctxp \entt c_r \T [\ctxm, x \T A](B \E \dirt) \\
        \Big[
          (\op \T A_\op \to B_\op) \in \sig \qquad
          \ctxp \entt c_\op \T [\ctxm, x \T A_\op, k \T B_\op \to B \E \dirt](B \E \dirt)
        \Big]_{\op \in \ops}
      }{
        \ctxp \entt \shorthand \T [\ctxm](A \E \dirt \union \ops \hto B \E \dirt)
      }
    
    \end{mathpar}
    \textbf{Computations}
    \begin{mathpar}
      \inferrule[SubComp]{
        \ctxp \entt c \T [\ctxm_1]\C_1 \\
        [\ctxm_1]\C_1 \le^\forall [\ctxm_2]\C_2
      }{
        \ctxp \entt c \T [\ctxm_2]\C_2
      }
    
      \inferrule[App]{
        \ctxp \entt v_1 \T [\ctxm](A \to \C) \\
        \ctxp \entt v_2 \T [\ctxm]A
      }{
        \ctxp \entt v_1 \, v_2 \T [\ctxm]\C
      }
    
      \inferrule[Cond]{
        \ctxp \entt v \T [\ctxm]bool \\
        \ctxp \entt c_1 \T [\ctxm]\C \\
        \ctxp \entt c_2 \T [\ctxm]\C \\
      }{
        \ctxp \entt \conditional{v}{c_1}{c_2} \T [\ctxm]\C
      }
    
      \inferrule[Ret]{
        \ctxp \entt v \T [\ctxm]A
      }{
        \ctxp \entt \ret v \T [\ctxm](A \E \emptyrow)
      }
    
      \inferrule[Op]{
        (\op \T A \to B) \in \sig \\
        \ctxp \entt v \T [\ctxm]A
      }{
        \ctxp \entt \op \, v \T [\ctxm](B \E \op)
      }
    
      \inferrule[Let]{
        \ctxp \entt v \T [\ctxm_1]A \\
        \ctxp, \letvar \T [\ctxm_1]A \entt c \T [\ctxm_2](B \E \dirt)
      }{
        \ctx \entt \letin{\letvar = v} c \T [\ctxm_1 \intersection \ctxm_2](B \E \dirt)
      }
      
      \inferrule[Do]{
        \ctxp \entt c_1 \T [\ctxm_1](A \E \dirt) \\
        \ctxp, \letvar \T [\ctxm_1]A \entt c_2 \T [\ctxm_2](B \E \dirt)
      }{
        \ctx \entt \doin{\letvar = c_1} c_2 \T [\ctxm_1 \intersection \ctxm_2](B \E \dirt)
      }
      
      \inferrule[With]{
        \ctxp \entt v \T [\ctxm](\C \hto \D) \\
        \ctxp \entt c \T [\ctxm]\C
      }{
        \ctxp \entt \withhandle{v}{c} \T [\ctxm]\D
      }
    
    \end{mathpar}
\end{minipage}
}
\end{center}
\caption{Reformulated typing rules of \core}\label{fig:core-reform-typing}
\end{figure}
    