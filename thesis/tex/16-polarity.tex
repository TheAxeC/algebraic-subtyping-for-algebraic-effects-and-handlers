This chapter describes the type inference algorithm for \core. Type inference has been brievely explained in Chapter~\ref{type-inference-explain}. It is the process where types are automatically inferred by the compiler. Typically, a type inference algorithm uses contraint-based type inference rules. For \core, we cannot immediately jump into these rules. There are quite a few steps to go through first. 

Typically, a type inference algortihm uses unification to solve the constraints generated by the type inference algorithm. In the case of a Hindley-Milner system, we can solve all rules generated by the type inference algorithm. With subtyping, not all rules are solved and a type may still contain constraints after inference has been completed. Algebraic subtyping uses an analogue for unification, called biunification, to encode the constraints into the intersection and union types.

In order to use biunification, we require polar types. The idea of polar types is to distinguish between input types and output types. Input types are used to describe inputs, while output types are used to describe outputs. Input and output types are represented as, respectively, negative and positive types in the terms of polar types. 

If we ever have a program in which we have to choose to produce an output of type $\C_1$ or $\C_2$, the actual output type is $\C_1 \union \C_2$. This could happen in the case of an \texttt{match} or \texttt{if} statement. In other situations, we may be in a situation where an input is used in a case where type $\C_1$ is required and in a case where type $\C_2$ is required, then the input is given $\C_1 \intersection \C_2$ as its type. Equivalently, this can also happen with pure types $A_1$ and $A_2$.  

In other words, input types only use intersections and output types only use unions. Polar types do not allow this convention to be broken. Making this restriction simplifies the problem of solving subtyping constraints greatly and allow them to be solved. \cite{dolan2017algebraic, pottier1998type} 

\section{Polar types}\label{polarity}

Figure~\ref{fig:types:core:polar} shows the polar type of \core. The separation of the union $\union$ and the intersection $\intersection$ types can be clearly seen. With the exception of the handler type, all types are equivalent to the system of algebraic subtyping. 

\todo{explain recursive types?}

Polarity also extends to typing schemes as seen in the typing context $\ctxp$. A polar typing scheme $[\ctxm^-]A^+$ has a positive type $A^+$ and a monomorphic environment consisting of $\lambda$-bound variables with negative types. 

The inference algorithm works only with polar typing schemes. The reader may wonder whether polar typing schemes are enough to infer a principal typing scheme. Dolan has shown that polar typing schemes do suffice, I extend his proof to incorporate algebraic effects and handlers in Chapter~\ref{principality}. \cite{dolan2017algebraic}

\begin{figure}[!htb]
\begin{center}
\framebox{
\begin{minipage}{0.98\columnwidth}
\[\begin{array}{r@{~}c@{~}l@{\quad}l}
    \text{polymorphic typing contexts}~\ctxp & \bnfis {} & \epsilon \bnfor \ctxp, \letvar : [\ctxm^-]A^+ \\
    \text{(pure) type}~A^+, B^+ & \bnfis {}
    & \boolty & \text{bool type} \\
    & \bnfor & A^- \to \C^+ & \text{function type} \\
    & \bnfor & \C^- \hto \D^+ & \textbf{handler type} \\
    & \bnfor & \alpha & \text{type variable} \\
    & \bnfor & \rectype{A^+} & \text{recursive type} \\
    & \bnfor & \bot & \text{bottom} \\
    & \bnfor & A^+ \union B^+ & \text{union} \\
    \text{dirty type}~\C^+, \D^+ & \bnfis {} & A^+ \E \dirt^+ \\

    \text{(pure) type}~A^-, B^- & \bnfis {}
    & \boolty & \text{bool type} \\
    & \bnfor & A^+ \to \C^- & \text{function type} \\
    & \bnfor & \C^+ \hto \D^- & \textbf{handler type} \\
    & \bnfor & \alpha & \text{type variable} \\
    & \bnfor & \rectype{A^-} & \text{recursive type} \\
    & \bnfor & \top & \text{top} \\
    & \bnfor & A^- \intersection B^- & \text{intersection} \\
    \text{dirty type}~\C^-, \D^- & \bnfis {} & A^- \E \dirt^- \\

    \text{dirt}~\dirt^+ & \bnfis {} & \op & \text{operation} \\
    & \bnfor & \delta & \text{dirt variable} \\
    & \bnfor & \emptyrow & \text{empty dirt} \\
    & \bnfor & \dirt_1^+ \union \dirt_2^+ & \text{union} \\

    \text{dirt}~\dirt^- & \bnfis {} & \op & \text{operation} \\
    & \bnfor & \delta & \text{dirt variable} \\
    & \bnfor & \allops & \text{full dirt (all operations, top)} \\
    & \bnfor & \dirt_1^- \intersection \dirt_2^- & \text{intersection}
\end{array}\]
\end{minipage}
}
\end{center}
\caption{Polar types of \core}\label{fig:types:core:polar}
\end{figure}
    